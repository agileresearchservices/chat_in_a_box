/**
 * Store Locator Parser Module
 * 
 * This module provides utilities for detecting and parsing store locator responses
 * from the PydanticAI-based store locator agent. It handles both successful store data
 * and various error conditions.
 * 
 * Key Features:
 * - Store locator response detection
 * - Structured store data parsing
 * - Error condition handling
 * 
 * @module StoreParser
 */

import logger from './logger';

/**
 * Store Data Interface
 * 
 * Defines the structure of a single store location data
 */
export interface StoreData {
  storeName: string;
  storeNumber: string;
  address: string;
  city: string;
  state: string;
  zipCode: string;
  phoneNumber: string;
}

/**
 * Store Response Data Interface
 * 
 * Defines the structure of the parsed store response
 */
export interface StoreResponse {
  stores: StoreData[];
  location: string;
  total: number;
  isError: boolean;
  errorMessage?: string;
}

/**
 * Detects if a message contains store locator information based on the format 
 * generated by the store locator agent.
 * 
 * @param {string} message - The message to check for store information
 * @returns {boolean} True if the message appears to be a store locator response
 */
export function isStoreLocatorResponse(message: string): boolean {
  // Check for specific store locator markers
  if (message.includes('<store-locator-query>') && message.includes('</store-locator-query>')) {
    return true;
  }
  
  // Return false if no store markers found
  return false;
}

/**
 * Parses a store locator response message into structured data
 * 
 * @param {string} message - The store locator response message to parse
 * @returns {StoreResponse | null} A structured StoreResponse object or null if parsing fails
 */
export function parseStoreLocatorData(message: string): StoreResponse | null {
  try {
    // Check if this is a properly formatted store locator response
    if (!isStoreLocatorResponse(message)) {
      return null;
    }
    
    // Extract the content between the markers
    const startMarker = '<store-locator-query>';
    const endMarker = '</store-locator-query>';
    
    const startIndex = message.indexOf(startMarker) + startMarker.length;
    const endIndex = message.indexOf(endMarker);
    
    if (startIndex === -1 || endIndex === -1) {
      return null;
    }
    
    const content = message.substring(startIndex, endIndex).trim();
    
    // Check for error responses
    if (content.includes("I couldn't find any stores") || content.includes("Error")) {
      return {
        stores: [],
        location: "Unknown",
        total: 0,
        isError: true,
        errorMessage: content
      };
    }
    
    // Parse the successful response
    // First line contains the location information
    const lines = content.split('\n');
    let locationLine = "";
    let location = "Unknown";
    
    // Look for the line with "I found X stores in Y:"
    for (const line of lines) {
      if (line.includes("I found") && line.includes("store")) {
        locationLine = line;
        break;
      }
    }
    
    // Extract location and total from the header line
    let total = 0;
    if (locationLine) {
      const countMatch = locationLine.match(/I found (\d+) store/);
      if (countMatch && countMatch[1]) {
        total = parseInt(countMatch[1], 10);
      }
      
      const locationMatch = locationLine.match(/store(?:s)? in ([^:]+):/);
      if (locationMatch && locationMatch[1]) {
        location = locationMatch[1].trim();
      }
    }
    
    // Parse store data
    const stores: StoreData[] = [];
    let currentStore: Partial<StoreData> = {};
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      
      // Skip empty lines and the header
      if (!line || line.includes("I found") || line.includes("Searching for stores")) {
        continue;
      }
      
      // New store entry starts with ðŸª
      if (line.startsWith('ðŸª')) {
        // Save previous store if it exists
        if (Object.keys(currentStore).length > 0) {
          stores.push(currentStore as StoreData);
        }
        
        // Start a new store entry
        currentStore = {};
        
        // Parse store name and number
        const storeMatch = line.match(/ðŸª\s+(.*)\s+\(Store #(.*)\)/);
        if (storeMatch) {
          currentStore.storeName = storeMatch[1];
          currentStore.storeNumber = storeMatch[2];
        }
      }
      // Address line starts with ðŸ“
      else if (line.startsWith('ðŸ“')) {
        const addressMatch = line.match(/ðŸ“\s+(.*),\s+(.*),\s+(.*)\s+(.*)$/);
        if (addressMatch) {
          currentStore.address = addressMatch[1];
          currentStore.city = addressMatch[2];
          currentStore.state = addressMatch[3];
          currentStore.zipCode = addressMatch[4];
        }
      }
      // Phone line starts with ðŸ“ž
      else if (line.startsWith('ðŸ“ž')) {
        const phoneMatch = line.match(/ðŸ“ž\s+(.*)$/);
        if (phoneMatch) {
          currentStore.phoneNumber = phoneMatch[1];
        }
      }
    }
    
    // Add the last store if it exists
    if (Object.keys(currentStore).length > 0) {
      stores.push(currentStore as StoreData);
    }
    
    // Create typed metadata object for logger
    const logData: Record<string, any> = {
      stores,
      location,
      total
    };
    logger.debug('Parsed store data:', logData);
    
    return {
      stores,
      location,
      total,
      isError: false
    };
  } catch (error) {
    logger.error('Error parsing store locator data:', error);
    return null;
  }
}
