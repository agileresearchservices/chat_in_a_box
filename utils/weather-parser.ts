import { WeatherData } from '@/app/components/WeatherCard';
import logger from './logger';

/**
 * Detects if a message contains weather information based on the format 
 * generated by the weather agent
 * 
 * @param message The message to check for weather information
 * @returns True if the message appears to be a weather response
 */
export function isWeatherResponse(message: string): boolean {
  // Check for all possible weather response patterns
  
  // 1. Successful weather request pattern (most common)
  if (message.includes('Making weather request for city:') && 
      (message.includes("Here's the") || message.includes('Here\'s the'))) {
    return true;
  }
  
  // 2. Error for invalid city name
  if (message.includes('Sorry, I couldn\'t get weather information for')) {
    return true;
  }
  
  // 3. Error for missing city
  if (message.includes('I couldn\'t understand which city you\'re asking about')) {
    return true;
  }
  
  // 4. Fallback pattern (just in case)
  const weatherPattern = /Here's the .+ weather for .+:\n?ðŸŒ¡ï¸ Temperature:/i;
  return weatherPattern.test(message);
}

/**
 * Parses weather information from a formatted weather response
 * 
 * @param message The weather response message to parse
 * @returns A WeatherData object or null if parsing fails
 */
export function parseWeatherData(message: string): WeatherData | null {
  try {
    // Handle error messages
    if (message.includes('I couldn\'t understand which city you\'re asking about')) {
      return {
        location: 'Unknown',
        temperature: 0,
        temperatureUnit: 'F',
        shortForecast: 'Error',
        detailedForecast: 'Please specify a city name.',
        timeframe: 'now',
        isError: true
      };
    }
    
    if (message.includes('Sorry, I couldn\'t get weather information for')) {
      const cityMatch = message.match(/for\s+([^,\s]+)/i);
      const city = cityMatch ? cityMatch[1] : 'Unknown';
      return {
        location: city,
        temperature: 0,
        temperatureUnit: 'F',
        shortForecast: 'Not Found',
        detailedForecast: `Weather information not available for ${city}.`,
        timeframe: 'now',
        isError: true
      };
    }
    
    // Check if it's the "Making weather request" format (main success path)
    if (message.includes('Making weather request for city:')) {
      // Parse the city from the request message
      const cityMatch = message.match(/city: '([^']+)'/i);
      const timeframeMatch = message.match(/timeframe: '([^']+)'/i);
      
      // Extract location from "Here's the ... weather for [location]:" pattern
      const locationMatch = message.match(/weather for ([^:]+):/i);
      if (!locationMatch || !locationMatch[1]) return null;
      const location = locationMatch[1].trim();
      
      // Parse the temperature
      const tempMatch = message.match(/Temperature: ([-\d.]+)Â°([CF])/i);
      if (!tempMatch || !tempMatch[1] || !tempMatch[2]) return null;
      const temperature = parseFloat(tempMatch[1]);
      const temperatureUnit = tempMatch[2];
      
      // Parse the short forecast (text after temperature)
      const parts = message.split('Temperature:');
      let shortForecast = '';
      if (parts.length >= 2) {
        // Get text after temperature value in the second part
        const afterTemp = parts[1].split('\n')[0];
        const forecastMatch = afterTemp.match(/[-\d.]+Â°[CF]\s+(.*)/i);
        if (forecastMatch && forecastMatch[1]) {
          shortForecast = forecastMatch[1].trim();
        }
      }
      
      // Parse the detailed forecast
      const detailedMatch = message.match(/Detailed Forecast:\s*([\s\S]+)$/i);
      const detailedForecast = detailedMatch ? detailedMatch[1].trim() : '';
      
      // Use extracted timeframe or default to "now"
      const timeframe = timeframeMatch && timeframeMatch[1] ? 
        mapTimeframeToKey(timeframeMatch[1].replace(/['"]/g, '')) : 'now';
      
      return {
        location,
        temperature,
        temperatureUnit,
        shortForecast,
        detailedForecast,
        timeframe,
        isError: false
      };
    }
    
    // Fallback - handle the original format
    // Parse the location
    const locationMatch = message.match(/weather for (.*?):/i);
    if (!locationMatch || !locationMatch[1]) return null;
    const location = locationMatch[1].trim();
    
    // Parse the temperature
    const tempMatch = message.match(/Temperature: ([-\d.]+)Â°([CF])/i);
    if (!tempMatch || !tempMatch[1] || !tempMatch[2]) return null;
    const temperature = parseFloat(tempMatch[1]);
    const temperatureUnit = tempMatch[2];
    
    // Parse the short forecast (line after temperature)
    const lines = message.split('\n').filter(line => line.trim() !== '');
    const shortForecastIndex = lines.findIndex(line => line.includes('Temperature:')) + 1;
    const shortForecast = shortForecastIndex < lines.length ? lines[shortForecastIndex].trim() : '';
    
    // Parse the detailed forecast (everything after "Detailed Forecast:")
    const detailedForecastIndex = lines.findIndex(line => line.includes('Detailed Forecast:'));
    let detailedForecast = '';
    if (detailedForecastIndex !== -1 && detailedForecastIndex + 1 < lines.length) {
      detailedForecast = lines.slice(detailedForecastIndex + 1).join('\n').trim();
    }
    
    // Parse the timeframe from the description
    const timeframeMatch = message.match(/Here's the (.*?) weather for/i);
    const timeframe = timeframeMatch && timeframeMatch[1] ? mapTimeframeToKey(timeframeMatch[1]) : 'now';
    
    return {
      location,
      temperature,
      temperatureUnit,
      shortForecast,
      detailedForecast,
      timeframe,
      isError: false
    };
  } catch (error) {
    logger.error('Error parsing weather data:', { error: String(error) });
    return null;
  }
}

/**
 * Maps the time description to a standardized timeframe key
 */
function mapTimeframeToKey(timeDescription: string): string {
  const descriptionLower = timeDescription.toLowerCase();
  
  if (descriptionLower === 'current') return 'now';
  if (descriptionLower.includes('today')) return 'today';
  if (descriptionLower.includes('tomorrow')) return 'tomorrow';
  if (descriptionLower.includes('tonight')) return 'tonight';
  if (descriptionLower.includes('week')) return 'week';
  if (descriptionLower.includes('weekend')) return 'weekend';
  
  return descriptionLower;
}
