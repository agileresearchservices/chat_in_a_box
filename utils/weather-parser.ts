/**
 * Weather Response Parser Module
 * 
 * This module provides utilities for detecting and parsing weather-related responses
 * from the PydanticAI-based weather agent. It handles both successful weather data
 * and various error conditions.
 * 
 * Key Features:
 * - Weather response detection
 * - Structured weather data parsing
 * - Error condition handling
 * - Support for current weather conditions
 * - Temperature and unit parsing
 * 
 * @module WeatherParser
 */

import { WeatherData } from '@/app/components/WeatherCard';
import logger from './logger';

/**
 * Detects if a message contains weather information based on the format 
 * generated by the weather agent.
 * 
 * Detection Patterns:
 * 1. Standard weather request response
 * 2. Invalid city name error
 * 3. Missing city error
 * 4. Fallback pattern for edge cases
 * 
 * @param {string} message - The message to check for weather information
 * @returns {boolean} True if the message appears to be a weather response
 * 
 * @example
 * // Returns true for valid weather response
 * isWeatherResponse("Making weather request for city: Boston\nHere's the weather...")
 * 
 * // Returns true for error response
 * isWeatherResponse("Sorry, I couldn't get weather information for XYZ")
 */
export function isWeatherResponse(message: string): boolean {
  // Check for all possible weather response patterns
  
  // 1. Successful weather request pattern (most common)
  if (message.includes('Making weather request for city:') && 
      (message.includes("Here's the") || message.includes('Here\'s the'))) {
    return true;
  }
  
  // 2. Error for invalid city name
  if (message.includes('Sorry, I couldn\'t get weather information for')) {
    return true;
  }
  
  // 3. Error for missing city
  if (message.includes('I couldn\'t understand which city you\'re asking about')) {
    return true;
  }
  
  // 4. Fallback pattern (just in case)
  const weatherPattern = /Here's the .+ weather for .+:\n?ðŸŒ¡ï¸ Temperature:/i;
  return weatherPattern.test(message);
}

/**
 * Parses weather information from a formatted weather response into a structured format.
 * Handles both successful weather data and error conditions.
 * 
 * Parsing Process:
 * 1. Error condition check and handling
 * 2. Location extraction
 * 3. Temperature and unit parsing
 * 4. Forecast extraction (short and detailed)
 * 
 * @param {string} message - The weather response message to parse
 * @returns {WeatherData | null} A structured WeatherData object or null if parsing fails
 * 
 * @example
 * // Returns WeatherData for successful response
 * parseWeatherData("Making weather request for city: Boston\nHere's the weather for Boston, MA:\nðŸŒ¡ï¸ Temperature: 72Â°F Sunny\nDetailed Forecast: Clear skies...")
 * 
 * // Returns error-state WeatherData for invalid input
 * parseWeatherData("Sorry, I couldn't get weather information for XYZ")
 */
export function parseWeatherData(message: string): WeatherData | null {
  try {
    // Handle error messages
    if (message.includes('I couldn\'t understand which city you\'re asking about')) {
      return {
        location: 'Unknown',
        temperature: 0,
        temperatureUnit: 'F',
        shortForecast: 'Error',
        detailedForecast: 'Please specify a city name.',
        timeframe: 'now',
        isError: true
      };
    }
    
    if (message.includes('Sorry, I couldn\'t get weather information for')) {
      const cityMatch = message.match(/for\s+([^,\s]+)/i);
      const city = cityMatch ? cityMatch[1] : 'Unknown';
      return {
        location: city,
        temperature: 0,
        temperatureUnit: 'F',
        shortForecast: 'Not Found',
        detailedForecast: `Weather information not available for ${city}.`,
        timeframe: 'now',
        isError: true
      };
    }
    
    // Check if it's the "Making weather request" format (main success path)
    if (message.includes('Making weather request for city:')) {
      // Parse the city from the request message
      const cityMatch = message.match(/city: '([^']+)'/i);
      
      // Extract location from "Here's the ... weather for [location]:" pattern
      const locationMatch = message.match(/weather for ([^:]+):/i);
      if (!locationMatch || !locationMatch[1]) return null;
      const location = locationMatch[1].trim();
      
      // Parse the temperature
      const tempMatch = message.match(/Temperature: ([-\d.]+)Â°([CF])/i);
      if (!tempMatch || !tempMatch[1] || !tempMatch[2]) return null;
      const temperature = parseFloat(tempMatch[1]);
      const temperatureUnit = tempMatch[2];
      
      // Parse the short forecast (text after temperature)
      const parts = message.split('Temperature:');
      let shortForecast = '';
      if (parts.length >= 2) {
        // Get text after temperature value in the second part
        const afterTemp = parts[1].split('\n')[0];
        const forecastMatch = afterTemp.match(/[-\d.]+Â°[CF]\s+(.*)/i);
        if (forecastMatch && forecastMatch[1]) {
          shortForecast = forecastMatch[1].trim();
        }
      }
      
      // Parse the detailed forecast
      const detailedMatch = message.match(/Detailed Forecast:\s*([\s\S]+)$/i);
      const detailedForecast = detailedMatch ? detailedMatch[1].trim() : '';
      
      return {
        location,
        temperature,
        temperatureUnit,
        shortForecast,
        detailedForecast,
        timeframe: 'now',
        isError: false
      };
    }
    
    // Fallback - handle the original format
    // Parse the location
    const locationMatch = message.match(/weather for (.*?):/i);
    if (!locationMatch || !locationMatch[1]) return null;
    const location = locationMatch[1].trim();
    
    // Parse the temperature
    const tempMatch = message.match(/Temperature: ([-\d.]+)Â°([CF])/i);
    if (!tempMatch || !tempMatch[1] || !tempMatch[2]) return null;
    const temperature = parseFloat(tempMatch[1]);
    const temperatureUnit = tempMatch[2];
    
    // Parse the short forecast (line after temperature)
    const lines = message.split('\n').filter(line => line.trim() !== '');
    const shortForecastIndex = lines.findIndex(line => line.includes('Temperature:')) + 1;
    const shortForecast = shortForecastIndex < lines.length ? lines[shortForecastIndex].trim() : '';
    
    // Parse the detailed forecast (everything after "Detailed Forecast:")
    const detailedForecastIndex = lines.findIndex(line => line.includes('Detailed Forecast:'));
    let detailedForecast = '';
    if (detailedForecastIndex !== -1 && detailedForecastIndex + 1 < lines.length) {
      detailedForecast = lines.slice(detailedForecastIndex + 1).join('\n').trim();
    }
    
    return {
      location,
      temperature,
      temperatureUnit,
      shortForecast,
      detailedForecast,
      timeframe: 'now',
      isError: false
    };
  } catch (error) {
    logger.error('Error parsing weather data:', { error: String(error) });
    return null;
  }
}
